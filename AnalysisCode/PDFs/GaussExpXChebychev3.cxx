/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// (Gaussian core + exponential tail) * 3rd order Chebyshev polynomial
// Souvik Das
// 8/1/2013

#include "Riostream.h" 

#include "GaussExpXChebychev3.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(GaussExpXChebychev3) 

GaussExpXChebychev3::GaussExpXChebychev3(const char *name, const char *title, 
                                         RooAbsReal& _x,
                                         RooAbsReal& _p0,
                                         RooAbsReal& _p1,
                                         RooAbsReal& _p2,
                                         RooAbsReal& _p3,
                                         RooAbsReal& _p4,
                                         RooAbsReal& _p5,
                                         RooAbsReal& _p6,
                                         RooAbsReal& _p7,
                                         RooAbsReal& _p8
                                        ) :
  RooAbsPdf(name,title), 
  x("x","x",this,_x),
  p0("p0","p0",this,_p0),
  p1("p1","p1",this,_p1),
  p2("p2","p2",this,_p2),
  p3("p3","p3",this,_p3),
  p4("p4","p4",this,_p4),
  p5("p5","p5",this,_p5),
  p6("p6","p6",this,_p6),
  p7("p7","p7",this,_p7),
  p8("p8","p8",this,_p8)
{ 
} 


GaussExpXChebychev3::GaussExpXChebychev3(const GaussExpXChebychev3& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  p0("p0",this,other.p0),
  p1("p1",this,other.p1),
  p2("p2",this,other.p2),
  p3("p3",this,other.p3),
  p4("p4",this,other.p4),
  p5("p5",this,other.p5),
  p6("p6",this,other.p6),
  p7("p7",this,other.p7),
  p8("p8",this,other.p8)
{ 
} 

Double_t GaussExpXChebychev3::evaluate() const 
{
   // GaussExp
   Double_t std=(x-p0)/p1;
   Double_t result=0;
   if (std<p2)
   {
     result=exp(-0.5*pow(std, 2));
   }
   else
   {
     result=exp(p2*p2/2.-p2*std);
   }
   
   // Chebyshev
   Double_t result_cheb=1e-6;
   if (x>p3 && x<p4)
   {
     Double_t x_eff=(x-(p3+p4)/2.)/(p4-p3);
     
     Double_t s1=p5;
     Double_t s2=p6*x_eff;
     Double_t s3=p7*(2.*x_eff*x_eff-1.);
     Double_t s4=p8*(4.*x_eff*x_eff*x_eff-3.*x_eff);
     
     Double_t result_cheb=s1+s2+s3+s4;
   }
   
   // Product of GaussExp and Chebyshev
   result=result*result_cheb;
   
   return result; 
} 



